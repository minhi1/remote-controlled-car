<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Remote Control Car</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <header>
    <h2>Remote Control Car</h2>
    <div class="status-bar">
      <span><span class="status-dot"></span>Car</span>
      <span id="camStatus"><span class="status-dot"></span>Cam</span>
    </div>
  </header>

  <main>
    <div class="main-container">
      <div class="center-column">

        <div class="controls-wrapper">
          <div class="controls">
            <button data-cmd="4">‚Üñ</button>
            <button data-cmd="2">‚Üë</button>
            <button data-cmd="5">‚Üó</button>

            <div></div>
            <button class="stop" data-cmd="1">STOP</button>
            <div></div>

            <button data-cmd="6">‚Üô</button>
            <button data-cmd="3">‚Üì</button>
            <button data-cmd="7">‚Üò</button>
          </div>

          <button class="capture-btn" onclick="captureFrame()">Capture (C)</button>

          <!-- <div class="upload-wrapper">
            <input type="file" id="file-input" style="display: none;">
            <button id="uploadButton" class="upload-btn">üìÇ Upload to AI</button>
          </div> -->
        </div>

        <div class="camera-wrapper">
          <img id="video" />

          <div class="audio-overlay">
            <button id="btnMicTx" class="audio-btn" title="Talk to Car">üé§</button>
            <button id="btnSpkRx" class="audio-btn" title="Listen to Car">üîä</button>
          </div>

          <div class="dashboard">
            <button class="gallery-btn" onclick="toggleGallery()">üìÅ Gallery</button>
          </div>
        </div>

        <div class="activity-log">
          <h3>Activity Log</h3>
          <div id="logContainer"></div>
        </div>
      </div>
    </div>
  </main>

  <div class="gallery" id="gallery">
    <button class="close-gallery" onclick="toggleGallery()">Close</button>
    <div class="gallery-grid" id="galleryGrid"></div>
  </div>

  <script>
    function addImageToGallery(img) {
      const item = document.createElement('div');
      item.className = 'gallery-item';
      item.appendChild(img);

      const tags = document.createElement('div');
      tags.className = 'tags';
      tags.innerText = 'Captured Frame';
      item.appendChild(tags);

      document.getElementById('galleryGrid').prepend(item);
    }

    // --- Load Gallery From Database
    async function loadGalleryFromDB() {
      console.log("Loading gallery from database...");
      const response = await fetch('/get-images');
      if (!response) {
        return null;
      }

      console.log(response);

      var images = null;

      try {
        images = await response.json();
      } catch (error) {
        console.log("Error decode json images:", error);
        return;
      }

      if (!images) {
        console.log("Error: Image is NULL");
        return;
      }

      console.log("Images:", images);

      if (!Array.isArray(images)) {
        console.log("images is not array data type");
        return;
      }

      images.forEach(element => {
        const img = new Image();

        img.src = element.url;
        img.style.width = '100px';

        // Add event listener for when image is clicked
        img.style.cursor = 'pointer';

        img.onclick = function() {
                console.log("Click on image...");
          openModal(element.url);
        };
        addImageToGallery(img);
      });
    }

    // --- Modal Logic ---
    let currentOpenedImage = null;

    function openModal(imageSrc) {
      const modal = document.getElementById("imageModal");
      const modalImg = document.getElementById("fullImage");
      console.log("Opening image...");

      modal.style.display = "flex"; // Show the modal
      modalImg.src = imageSrc;      // Set the image source

      // Set current opened image
      currentOpenedImage = imageSrc;
    }

    async function analyzeCurrentImage() {
      if (!currentOpenedImage) return;

      const btn = document.getElementById('btnAnalyze');
      const resultBox = document.getElementById('analysisResult');
      const originalText = btn.innerText;

      // 1. Show loading state
      btn.innerText = "‚è≥ Analyzing...";
      btn.disabled = true;
      resultBox.style.display = 'none';
      resultBox.innerHTML = '';

      try {
        // 2. Send to Backend as JSON
        const response = await fetch('/analyze-image', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json' // Important for Base64
          },
          body: JSON.stringify({ image: currentOpenedImage })
        });

        const data = await response.json();
        console.log("Analysis Result:", data);

        // 3. Display Result
        if (data.result && data.result.tags) {
          // Take top 5 tags
          const tags = data.result.tags.slice(0, 5);

          tags.forEach(item => {
            const name = item.tag.en;
            const confidence = item.confidence.toFixed(1); // e.g., 95.5

            // Create HTML for this row
            const row = document.createElement('div');
            row.className = 'tag-row';
            row.innerHTML = `
              <span class="tag-name">${name}</span>
              <div class="tag-bar-bg">
                <div class="tag-bar-fill" style="width: ${confidence}%"></div>
              </div>
              <span class="tag-score">${confidence}%</span>
            `;
            resultBox.appendChild(row);
          });

          // Show the box
          resultBox.style.display = 'block';

        } else {
          resultBox.innerText = "No objects detected.";
          resultBox.style.display = 'block';
        }

        addLog("Analysis received", "success");

      } catch (error) {
        console.error("Analysis failed:", error);
        alert("Analysis failed. Check console.");
      } finally {
        // 4. Reset Button
        btn.innerText = originalText;
        btn.disabled = false;
      }
    }

    function closeModal() {
      document.getElementById("imageModal").style.display = "none";
    }

    // Optional: Close modal if user clicks on the black background (outside image)
    function closeModalOnBg(event) {
      if (event.target.id === "imageModal") {
        closeModal();
      }
    }

    loadGalleryFromDB();

    // --- CONFIGURATION ---
    const STOP_CMD = 1;
    const TARGETSR = 16000;
    const FRAMEMS = 20;
    const BYTESPERSAMPLE = 2; // PCM16
    const SAMPLESPERFRAME = TARGETSR * FRAMEMS / 1000; // 320
    const BYTESPERFRAME = SAMPLESPERFRAME * BYTESPERSAMPLE; // 640
    const PREBUFFERMS = 200;
    const PREBUFFERBYTES = TARGETSR * PREBUFFERMS / 1000 * BYTESPERSAMPLE;

    // --- ELEMENTS ---
    const videoEl = document.getElementById('video');
    const camStatusEl = document.getElementById('camStatus');
    const buttons = document.querySelectorAll('[data-cmd]');
    const logContainer = document.getElementById('logContainer');

    // Upload Elements
    const uploadButton = document.getElementById('uploadButton');
    const fileInput = document.getElementById('file-input');

    // Audio Elements
    const btnMicTx = document.getElementById('btnMicTx');
    const btnSpkRx = document.getElementById('btnSpkRx');

    // State
    let wsCar, wsCam;
    let pingStart = 0;
    let lastPing = 0;

    // --- UTILS ---
    function addLog(message, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      const time = new Date().toLocaleTimeString();
      entry.innerHTML = `<div class="time">${time}</div><div class="message">${message}</div>`;
      logContainer.insertBefore(entry, logContainer.firstChild);
      while (logContainer.children.length > 50) logContainer.removeChild(logContainer.lastChild);
    }

    function getWsUrl(path) {
      return `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}${path}`;
    }

    // --- 2. Car Control ---
    function setActive(cmd) {
      buttons.forEach(b => b.classList.toggle('active', b.dataset.cmd == cmd));
    }

    function sendCmd(cmd) {
      setActive(cmd);
      if (wsCar?.readyState === 1) wsCar.send(String(cmd));

      const cmdNames = {
        1: 'STOP', 2: 'Forward', 3: 'Backward',
        4: 'Forward-Left', 5: 'Forward-Right',
        6: 'Backward-Left', 7: 'Backward-Right'
      };
      // Only log non-stop commands to reduce spam, or keep all
      if(cmd != STOP_CMD) addLog(`Cmd: ${cmdNames[cmd] || cmd}`, 'info');
    }

    setActive(STOP_CMD);

    buttons.forEach(btn => {
      btn.addEventListener('mousedown', () => sendCmd(btn.dataset.cmd));
      btn.addEventListener('mouseup', () => sendCmd(STOP_CMD));
      btn.addEventListener('mouseleave', () => sendCmd(STOP_CMD));
    });

    // Keyboard Control
    const keys = new Set();
    document.addEventListener('keydown', e => {
      if (e.repeat) return;
      if (e.key.toLowerCase() === 'c') return captureFrame();
      keys.add(e.key.toLowerCase());
      handleKeys();
    });
    document.addEventListener('keyup', e => {
      keys.delete(e.key.toLowerCase());
      handleKeys();
    });

    function handleKeys() {
      const w = keys.has('w') || keys.has('arrowup');
      const s = keys.has('s') || keys.has('arrowdown');
      const a = keys.has('a') || keys.has('arrowleft');
      const d = keys.has('d') || keys.has('arrowright');

      if (w && a) sendCmd(4);
      else if (w && d) sendCmd(5);
      else if (s && a) sendCmd(6);
      else if (s && d) sendCmd(7);
      else if (w) sendCmd(2);
      else if (s) sendCmd(3);
      else sendCmd(STOP_CMD);
    }

    // --- 3. Camera capture and Gallery ---
    function captureFrame() {
      if (!videoEl.src) {
        console.log("Video has no source!!!");
        return;
      }

      console.log("Video source:");
      console.log(videoEl.src);

      // Create a temporary canvas to draw the current frame
      const canvas = document.createElement('canvas');

      // Use naturalWidth to get the real resolution of the camera
      // not the CSS size
      canvas.width = videoEl.naturalWidth;
      canvas.height = videoEl.naturalHeight;

      const ctx = canvas.getContext('2d');

      // 3. Draw the current state of the video element onto the canvas
      // This extracts the PIXELS, ignoring the dead Blob URL
      ctx.drawImage(videoEl, 0, 0);

      // 4. Convert the canvas content to a base64 Data URL (a static image string)
      const dataURL = canvas.toDataURL('image/jpeg');

      fetch('/host-image-b64', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        // Send the dataURL as a JSON object
        body: JSON.stringify({ image: dataURL })
      })
      .then(resp => {
        console.log("Response from ImgBB:", resp);
        return resp;
      })
      .catch(err => {
        console.error('Error uploading img to imgBB', err);
        addLog('Failed hosting image', 'error');
      });

      const img = new Image();

      img.src = dataURL;
      img.style.width = '100px';

      // Add event listener for when image is clicked
      img.style.cursor = 'pointer';

      console.log("Create onclick() function for img");
      img.onclick = function() {
              console.log("Click on image...");
        openModal(dataURL);
      };

      addImageToGallery(img);
      addLog('Frame captured', 'success');
    }

    function toggleGallery() {
      document.getElementById('gallery').classList.toggle('open');
    }

    function updateCamStatus() {
      camStatusEl.innerHTML = `<span class="status-dot"></span> ${lastPing}ms`;
      requestAnimationFrame(updateCamStatus);
    }
    updateCamStatus();

    // --- 4. Audio ---

    // >> Speaker RX (ESP32 -> Browser)
    let spkRxOn = false;
    let listenEnabled = false;
    let wsMic = null;
    let playCtx = null;
    let playerNode = null;
    let micQueue = [];
    let micQueuedBytes = 0;
    let pumpTimer = null;
    let started = false;

    function resetMicBuffer() {
      micQueue = [];
      micQueuedBytes = 0;
      started = false;
      if (pumpTimer) clearInterval(pumpTimer);
      pumpTimer = null;
    }

    function popBytes(n) {
      if (micQueuedBytes < n) return null;
      const out = new Uint8Array(n);
      let off = 0;
      while (off < n && micQueue.length) {
        const c = micQueue[0];
        const take = Math.min(c.length, n - off);
        out.set(c.subarray(0, take), off);
        off += take;
        if (take === c.length) micQueue.shift();
        else micQueue[0] = c.subarray(take);
        micQueuedBytes -= take;
      }
      return out;
    }

    async function ensurePlayGraph() {
      if (playCtx) return;
      playCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: TARGETSR });

      const workletCode = `
        class PcmPlayer extends AudioWorkletProcessor {
          constructor() {
            super();
            this.q = [];
            this.g = 1.0;
            this.port.onmessage = (e) => {
              if (e.data && e.data.pcm) this.q.push(e.data.pcm);
              if (e.data && typeof e.data.gain === 'number') this.g = e.data.gain;
              if (e.data && e.data.reset) this.q = [];
            };
          }
          process(inputs, outputs) {
            const out = outputs[0][0];
            out.fill(0);
            let o = 0;
            while (o < out.length && this.q.length) {
              const b = this.q[0];
              const n = Math.min(b.length, out.length - o);
              for (let i = 0; i < n; i++) out[o + i] = b[i] * this.g;
              if (n === b.length) this.q.shift();
              else this.q[0] = b.subarray(n);
              o += n;
            }
            return true;
          }
        }
        registerProcessor('pcm-player', PcmPlayer);
      `;
      const blobURL = URL.createObjectURL(new Blob([workletCode], { type: 'application/javascript' }));
      await playCtx.audioWorklet.addModule(blobURL);
      URL.revokeObjectURL(blobURL);

      playerNode = new AudioWorkletNode(playCtx, 'pcm-player', {
        numberOfInputs: 0,
        numberOfOutputs: 1,
        outputChannelCount: [1],
      });
      playerNode.connect(playCtx.destination);
    }

    async function startPump() {
      if (pumpTimer) return;
      await ensurePlayGraph();
      if (playCtx.state !== 'running') await playCtx.resume();

      pumpTimer = setInterval(() => {
        if (!listenEnabled) return;
        if (!started) {
          if (micQueuedBytes < PREBUFFERBYTES) return;
          started = true;
        }
        const frame = popBytes(BYTESPERFRAME);
        if (!frame) return;

        const s16 = new Int16Array(frame.buffer, frame.byteOffset, frame.byteLength / 2);
        const f32 = new Float32Array(s16.length);
        for (let i = 0; i < s16.length; i++) f32[i] = s16[i] / 32768;

        playerNode.port.postMessage({ pcm: f32 });
      }, FRAMEMS);
    }

    function connectMicWs() {
      wsMic = new WebSocket(getWsUrl('/mic'));
      wsMic.binaryType = 'arraybuffer';
      wsMic.onopen = () => addLog('Speaker RX Connected', 'success');
      wsMic.onerror = () => addLog('Speaker RX Error', 'error');
      wsMic.onclose = () => {
        addLog('Speaker RX Closed', 'warning');
        wsMic = null;
        resetMicBuffer();
        if (spkRxOn) setTimeout(connectMicWs, 1000);
      };
      wsMic.onmessage = async (ev) => {
        if (!(ev.data instanceof ArrayBuffer)) return;
        const u8 = new Uint8Array(ev.data);
        micQueue.push(u8);
        micQueuedBytes += u8.length;
        const MAXQUEUEBYTES = TARGETSR * 1.0 * BYTESPERSAMPLE;
        while (micQueuedBytes > MAXQUEUEBYTES && micQueue.length) {
          micQueuedBytes -= micQueue[0].length;
          micQueue.shift();
          started = false;
        }
        if (listenEnabled) await startPump();
      };
    }

    function stopSpkRx() {
      listenEnabled = false;
      resetMicBuffer();
      if (playerNode) {
        try { playerNode.port.postMessage({ reset: true }); } catch {}
        try { playerNode.disconnect(); } catch {}
        playerNode = null;
      }
      if (playCtx) {
        try { playCtx.close(); } catch {}
        playCtx = null;
      }
      if (wsMic) {
        try { wsMic.close(); } catch {}
        wsMic = null;
      }
    }

    // >> Mic TX (Browser -> ESP32)
    let micTxOn = false;
    let talkEnabled = false;
    let wsSpeaker = null;
    let talkStream = null;
    let talkCtx = null;
    let talkNode = null;
    let talkZeroGain = null;

    function connectSpeakerWs() {
      wsSpeaker = new WebSocket(getWsUrl('/speaker'));
      wsSpeaker.binaryType = 'arraybuffer';
      wsSpeaker.onopen = () => addLog('Mic TX Connected', 'success');
      wsSpeaker.onerror = () => addLog('Mic TX Error', 'error');
      wsSpeaker.onclose = () => {
        addLog('Mic TX Closed', 'warning');
        wsSpeaker = null;
        if (micTxOn) setTimeout(connectSpeakerWs, 1000);
      };
    }

    async function startTalk() {
      if (!wsSpeaker || wsSpeaker.readyState !== WebSocket.OPEN) {
        addLog('Mic TX WS not ready', 'warning');
        return;
      }
      talkStream = await navigator.mediaDevices.getUserMedia({
        audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true, autoGainControl: true },
        video: false
      });
      talkCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: TARGETSR });
      const src = talkCtx.createMediaStreamSource(talkStream);
      const bufSize = 1024;
      talkNode = talkCtx.createScriptProcessor(bufSize, 1, 1);

      talkZeroGain = talkCtx.createGain();
      talkZeroGain.gain.value = 0;

      talkNode.onaudioprocess = (e) => {
        if (!talkEnabled) return;
        if (!wsSpeaker || wsSpeaker.readyState !== WebSocket.OPEN) return;
        const input = e.inputBuffer.getChannelData(0);
        const pcm16 = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
          let s = Math.max(-1, Math.min(1, input[i]));
          pcm16[i] = s < 0 ? s * 32768 : s * 32767;
        }
        wsSpeaker.send(pcm16.buffer);
      };

      src.connect(talkNode);
      talkNode.connect(talkZeroGain);
      talkZeroGain.connect(talkCtx.destination);
      talkEnabled = true;
    }

    async function stopTalk() {
      talkEnabled = false;
      if (talkNode) { try { talkNode.disconnect(); } catch {} }
      if (talkZeroGain) { try { talkZeroGain.disconnect(); } catch {} }
      if (talkCtx) { try { await talkCtx.close(); } catch {} }
      talkNode = null; talkZeroGain = null; talkCtx = null;
      if (talkStream) {
        try { talkStream.getTracks().forEach(t => t.stop()); } catch {}
        talkStream = null;
      }
      if (wsSpeaker) {
        try { wsSpeaker.close(); } catch {}
        wsSpeaker = null;
      }
    }

    // >> Audio Toggle Buttons
    btnSpkRx.onclick = async () => {
      btnSpkRx.classList.remove('err');
      if (spkRxOn) {
        spkRxOn = false;
        btnSpkRx.classList.remove('on');
        stopSpkRx();
        return;
      }
      try {
        spkRxOn = true;
        btnSpkRx.classList.add('on');
        listenEnabled = true;
        resetMicBuffer();
        if (!wsMic) connectMicWs();
        await ensurePlayGraph();
        if (playCtx.state !== 'running') await playCtx.resume();
        await startPump();
      } catch (e) {
        spkRxOn = false;
        btnSpkRx.classList.remove('on');
        btnSpkRx.classList.add('err');
        stopSpkRx();
        addLog(`Error: ${e.message}`, 'error');
      }
    };

    btnMicTx.onclick = async () => {
      btnMicTx.classList.remove('err');
      if (micTxOn) {
        micTxOn = false;
        btnMicTx.classList.remove('on');
        await stopTalk();
        return;
      }
      try {
        micTxOn = true;
        btnMicTx.classList.add('on');
        if (!wsSpeaker) connectSpeakerWs();
        const t0 = performance.now();
        while (!wsSpeaker || wsSpeaker.readyState !== WebSocket.OPEN) {
          if (performance.now() - t0 > 3000) break;
          await new Promise(r => setTimeout(r, 50));
        }
        await startTalk();
      } catch (e) {
        micTxOn = false;
        btnMicTx.classList.remove('on');
        btnMicTx.classList.add('err');
        await stopTalk();
        addLog(`Error: ${e.message}`, 'error');
      }
    };

    window.addEventListener('beforeunload', () => {
      try { stopSpkRx(); } catch {}
      try { stopTalk(); } catch {}
    });


    // --- 5. Initialize WebSocket /car & /cam ---
    wsCar = new WebSocket(getWsUrl('/car'));
    wsCar.onopen = () => addLog('Car Connected', 'success');
    wsCar.onerror = () => addLog('Car Connection Error', 'error');
    wsCar.onclose = () => addLog('Car Disconnected', 'warning');

    wsCam = new WebSocket(getWsUrl('/cam'));
    wsCam.binaryType = 'arraybuffer';
    wsCam.onopen = () => {
      addLog('Camera Connected', 'success');
      setInterval(() => {
        pingStart = performance.now();
        wsCam.send('ping');
      }, 2000);
    };
    wsCam.onerror = () => addLog('Cam Error', 'error');
    wsCam.onclose = () => addLog('Cam Disconnected', 'warning');

    let currentCamUrl = null;

    wsCam.onmessage = (e) => {
      if (e.data instanceof ArrayBuffer) {
        const blob = new Blob([e.data], { type: 'image/jpeg' });
        const newUrl = URL.createObjectURL(blob);
        videoEl.src = newUrl;
        videoEl.onload = () => {
          if (currentCamUrl) URL.revokeObjectURL(currentCamUrl); // Revoke previous
          currentCamUrl = newUrl;  // Update reference
        };
        videoEl.onerror = () => {
          addLog('Failed to load camera frame', 'error');
          URL.revokeObjectURL(newUrl); // Clean up on error
        };
        // const blob = new Blob([e.data], { type: 'image/jpeg' });
        // const reader = new FileReader();
        // reader.onload = () => {
        //  videoEl.src = reader.result;
        // };
        reader.readAsDataURL(blob);
        // const url = URL.createObjectURL(new Blob([e.data], { type: 'image/jpeg' }));
        // videoEl.src = url;
        // videoEl.onload = () => URL.revokeObjectURL(url);
      } else if (e.data === 'ping') {
        lastPing = Math.round(performance.now() - pingStart);
      }
    };

    addLog('System Initialized', 'success');
  </script>

  <div id="imageModal" class="modal" onclick="closeModalOnBg(event)">
    <span class="close-btn" onclick="closeModal()">&times;</span>
    <div style="position: relative; text-align: center;">
      <img class="modal-content" id="fullImage">

      <button id="btnAnalyze" class="analyze-btn" onclick="analyzeCurrentImage()">
        üîç Analyze Image
      </button>

      <div id="analysisResult" class="analysis-result"></div>
    </div>
    <!-- <img class="modal-content" id="fullImage"> -->
  </div>
</body>
</html>
